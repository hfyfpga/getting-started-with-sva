\documentclass{beamer}
\usepackage{textcomp}

\usetheme{Warsaw}
\title{Getting started with SystemVerilog Assertions}
\author{Tudor Timi}
\institute{VerificationGentleman.com}
\date{April 15, 2020}
\begin{document}


\begin{frame}
\titlepage
\end{frame}


\begin{frame}{Introduction}
SystemVerilog assertions (SVAs) express temporal behavior

\begin{itemize}
 \item Compact
 \item Similar to regular expressions
\end{itemize}
\end{frame}


\begin{frame}{Top 6 essential SVA features}
\begin{itemize}
 \item Implication operator
 \item Delay operation
 \item Repetition operator
 \item Throughout operator
 \item Named properties and sequences
 \item Sequence.triggered
\end{itemize}
\end{frame}


\begin{frame}{Implication}
Overlapping implication:

\begin{semiverbatim}
antecedent |-> consequent
\end{semiverbatim}

\begin{itemize}
 \item If antecedent is 1, then consequent must be 1 as well
 \item If antecedent is 0, then consequent can have any value
\end{itemize}

\pause
Don't grant any requests while busy:
\begin{semiverbatim}
assert property (busy |-> !grant);
\end{semiverbatim}

\pause
New request while not busy is granted immediately:
\begin{semiverbatim}
assert property (req \&\& !busy |-> grant);
\end{semiverbatim}
\end{frame}


\begin{frame}[fragile]{Implication}
Overlapping implication using immediate assert:

\begin{semiverbatim}
always @(posedge clk)
  if (antecedent)
    assert (consequent);
\end{semiverbatim}
\end{frame}


\begin{frame}{Implication}
Non-overlapping implication:

\begin{semiverbatim}
antecedent |=> consequent
\end{semiverbatim}

\begin{itemize}
 \item If antecedent is 1, then in the next cycle consequent must be 1 as well
 \item If antecedent is 0, then consequent can have any value
\end{itemize}

\pause
Start working on granted requests:
\begin{semiverbatim}
assert property (req \&\& grant |=> busy);
\end{semiverbatim}
\end{frame}


\begin{frame}[fragile]{Implication}
Non-overlapping using immediate assert:

\begin{semiverbatim}
always @(posedge clk)
  if (\$past(antecedent))
    assert (consequent);
\end{semiverbatim}

\pause
\begin{alertblock}{Gotcha}
\$past(...) can be either 0 or 1 in the very first cycle \textrightarrow{} false negative
\end{alertblock}
\end{frame}


\begin{frame}[fragile]{Implication}
Non-overlapping using immediate assert (corrected):

\begin{semiverbatim}
always @(posedge clk)
  if (past_valid \&\& \$past(antecedent))
    assert (consequent);
\end{semiverbatim}

\begin{semiverbatim}
bit past_valid = 0;
always @(posedge clk)
  past_valid <= 1;
\end{semiverbatim}
\end{frame}


\begin{frame}{Delay}
One cycle delay:

\begin{semiverbatim}
a \#\#1 b
\end{semiverbatim}

\begin{itemize}
 \item a is 1 in the 1st cycle and b is also 1 in the 2nd cycle
\end{itemize}

\pause
Delay of multiple cycles:

\begin{semiverbatim}
a \#\#3 b
\end{semiverbatim}

\begin{itemize}
 \item a is 1 in the 1st cycle and b is also 1 in the 4th cycle
\end{itemize}
\end{frame}


\begin{frame}{Delay}

Delay in antecedent:
\begin{semiverbatim}
assert property (a \#\#1 b |=> c);
\end{semiverbatim}

\begin{itemize}
 \item If a is 1 in the 1st cycle and b is 1 in the 2nd cycle, then c must be 1 in the 3rd cycle
\end{itemize}

\pause

Delay in consequent:
\begin{semiverbatim}
assert property (c |=> a \#\#1 b);
\end{semiverbatim}

\begin{itemize}
 \item If c is 1 in the 1st cycle, then a must be 1 in the 2nd cycle and a must be 1 in the 3rd cycle
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Delay}
One cycle delay using RTL modeling:

\begin{semiverbatim}
enum \{ IDLE, A_SEEN, END \} state, next_state;
bit match;

always_comb begin
  next_state = state;
  case (state)
    IDLE: if (a) next_state = A_SEEN;
    A_SEEN: next_state = END;
  endcase
end

assign match = (state == A_SEEN) && b;
\end{semiverbatim}

\pause
\begin{alertblock}{Gotcha}
Not equivalent to SVA. Doesn't start a new attempt on each cycle.
\end{alertblock}
\end{frame}


\begin{frame}{Modeling SVA sequences using RTL}
It's more difficult than it appears at first glance. A great resource on the topic is this post:
\url{https://tomverbeure.github.io/rtl/2019/01/04/Under-the-Hood-of-Formal-Verification.html}
\end{frame}


\begin{frame}[fragile]{Delay}
Delay of three cycles using naive RTL modeling:

\begin{semiverbatim}
enum \{ IDLE, A_SEEN, WAIT1, WAIT2, END \} state, ...;

always_comb begin
  next_state = state;
  case (state)
    IDLE: if (a) next_state = A_SEEN;
    A_SEEN: next_state = WAIT1;
    WAIT1: next_state = WAIT2;
    WAIT2: next_state = END;
  endcase
end

assign match = (state == WAIT2) && b;
\end{semiverbatim}
\end{frame}


\begin{frame}{Repetition}
Consecutive repetition:

\begin{semiverbatim}
a [*5]
\end{semiverbatim}

\begin{itemize}
 \item a is 1 in the 1st, 2nd, 3rd, 4th and 5th cycles
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Repetition}
Consecutive repetition (5 times) using immediate cover:

\begin{semiverbatim}
int unsigned counter;

always_ff @(posedge clk)
  if (a && counter < 5-1) counter++;
  else counter = 0;

assign match = (counter == 5-1 && a);

always @(posedge clk)
  cover (match);
\end{semiverbatim}
\end{frame}


\begin{frame}[fragile]{Repetition}
Goto repetition:

\begin{semiverbatim}
a ##1 b [->1]
\end{semiverbatim}

\begin{itemize}
 \item a is 1 in the 1st and b is high in any future cycle from cycle 2 onward
\end{itemize}

\begin{block}{Note}
a \#\#1 is not part of the goto repetition definition, but it makes the explanation easier.
\end{block}
\end{frame}


\begin{frame}[fragile]{Repetition}
Goto repetition using immediate cover:

\begin{itemize}
 \item haven't tried it out
 \item some kind of counter with b as an enable?
\end{itemize}

\pause
Modeling using RTL becomes more and more complicated
\begin{itemize}
 \item worth it?
\end{itemize}
\end{frame}


\begin{frame}{Throughout}
\begin{itemize}
 \item TODO Add code for concurrent
\end{itemize}
\end{frame}


\begin{frame}{Throughout}
Discussion
\begin{itemize}
 \item TODO Add code for throughout as assume (No pipelining)
 \item TODO Add code for throughout as assert (No ready during first 5 cycles of operation)
\end{itemize}
\end{frame}


\begin{frame}{Named properties and sequences}
TODO Add notes about reuse
\end{frame}


\begin{frame}{Named properties and sequences}
Named property
\begin{itemize}
 \item TODO Add code
\end{itemize}
\end{frame}


\begin{frame}{Named properties and sequences}
Named sequence
\begin{itemize}
 \item TODO Add code
\end{itemize}
\end{frame}


\begin{frame}{Sequence.triggered}
\begin{itemize}
 \item TODO Add code
\end{itemize}
\end{frame}


\begin{frame}{Tips and tricks}
Split long sequences

\begin{itemize}
 \item Functions calling functions \textrightarrow{} sequences composed of sequences
\end{itemize}
\end{frame}


\begin{frame}{Tips and tricks}
Mulitple smaller assertions instead of one big assertion

\begin{itemize}
 \item Easier to write/read
 \item Easier to debug
 \item More difficult to reason about (all requirements?)
\end{itemize}
\end{frame}


\begin{frame}{Tips and tricks}
Check that properties work as expected

\begin{itemize}
 \item SVUnit
 \item Dream: test using SymbiYosys
\end{itemize}
\end{frame}


\begin{frame}{Tips and tricks}
Think about cause, not just effect

\begin{itemize}
 \item TODO Add code for implication in both directions
\end{itemize}
\end{frame}


\end{document}